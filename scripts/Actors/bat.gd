extends CharacterBody2D

@onready var animator: AnimationPlayer = $AnimationPlayer
var navigation: RTTstarNavigationGD
var nd: HolonomicND
var FLY_SPEED: float = 2 * World.ppu
const DISTANCE_EPSILON: float = World.ppu * 0.5
var _path_display: RTTstarDisplay = null

func _ready() -> void:
	animator.play("Fly")
	
	navigation = RTTstarNavigationGD.new()
	nd = HolonomicND.new()
	
	add_child(navigation)
	add_child(nd)

	_path_display = RTTstarDisplay.new()
	_path_display.show_connections = true
	_path_display.marker_radius = 8.0
	_path_display.marker_outline_width = 1.0
	World.add_child(_path_display)


## Returns the path index that the actor should head towards
func _go_to_trajectory(new_path: PackedVector2Array) -> int:
	var min_dist = INF
	var best_segment = 0
	
	# Find closest point on path segments
	for i in range(new_path.size() - 1):
		var closest = Geometry2D.get_closest_point_to_segment(global_position, new_path[i], new_path[i + 1])
		var dist = global_position.distance_squared_to(closest)
		if dist < min_dist:
			min_dist = dist
			best_segment = i

	return best_segment + 1


## Follow a trajectory generated by the navigation system
func _physics_process(_delta: float) -> void:
	var player := Player.global_position
	var target: Vector2

	# Direct path to player is clear, go directly
	if not World.ray_intersects_ground(global_position, player):
		target = player
	else:
		###################### Global navigation #########################

		var path := navigation.generate_trajectory(global_position, player)
		if path.is_empty():
			World.log("No path found for actor at ", global_position, " to player at ", player)
			velocity = Vector2.ZERO
			return

		# Compute where in the path we should go
		var target_idx := _go_to_trajectory(path)

		# Check that the path is reachable
		if World.ray_intersects_ground(global_position, path[target_idx]):
			navigation.restart(global_position)
			World.log("Actor cannot travel to path node ", path[target_idx], ", clearing tree")
			return

		# We are already at the target, move to the next one
		if global_position.distance_to(path[target_idx]) < DISTANCE_EPSILON \
			and target_idx < path.size() - 1:
				target_idx += 1 # Move to the next target

		# Update path display
		if _path_display:
			_path_display.set_positions(path)
			_path_display.set_current_objective(target_idx)

		target = path[target_idx]

	# Compute direction to the next target
	var direction := nd.compute_direction(global_position, target)
	velocity = direction * FLY_SPEED
	move_and_slide() # Update physics

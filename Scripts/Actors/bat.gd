extends CharacterBody2D


@export var FLY_SPEED: float = 1 * World.ppu

var navigation: RTTstarNavigationGD
var nd: HolonomicND
const DISTANCE_EPSILON: float = World.ppu * 0.5
var _path_display: RTTstarDisplay = null

## Follow a trajectory generated by the navigation system
func _physics_process(_delta: float) -> void:
	
	var target := _compute_direction()
	var direction := nd.compute_direction(global_position, target)

	velocity = direction * FLY_SPEED

	if velocity.x != 0 and sign(velocity.x) != looking_dir_x():
		scale.x = -scale.x

	move_and_slide() # Update physics


## Compute the direction to the player, using navigation if needed
func _compute_direction() -> Vector2:
	var player = Player.target_point()

	# Direct path to player is clear, go directly
	if not World.ray_intersects_ground(global_position, player):
		return player
	else:
		###################### Global navigation #########################

		var path := navigation.generate_trajectory(global_position, player)
		if path.is_empty():
			World.log("No path found for actor at ", global_position, " to player at ", player)
			velocity = Vector2.ZERO
			return Vector2.ZERO

		# Compute where in the path we should go
		var target_idx := _go_to_trajectory(path)

		# Check that the path is reachable
		if World.ray_intersects_ground(global_position, path[target_idx]):
			navigation.restart(global_position)
			World.log("Actor cannot travel to path node ", path[target_idx], ", clearing tree")
			return Vector2.ZERO

		# Update path display
		if _path_display:
			_path_display.set_positions(path)
			_path_display.set_current_objective(target_idx)

		return path[target_idx]


## Returns the path index that the actor should head towards from a given trajectory
func _go_to_trajectory(new_path: PackedVector2Array) -> int:
	var min_dist = INF
	var best_segment = 0
	
	# Find closest point on path segments
	for i in range(new_path.size() - 1):
		var closest = Geometry2D.get_closest_point_to_segment(global_position, new_path[i], new_path[i + 1])
		var dist = global_position.distance_squared_to(closest)
		if dist <= min_dist: # Favor later segments in case of ties
			min_dist = dist
			best_segment = i
	
	var target = best_segment + 1

	# We have the closest segment. Now, if the next point is not obstructed, we directly go to it
	if target + 1 < new_path.size() and not World.ray_intersects_ground(global_position, new_path[target + 1]):
		target += 1

	return target


func actor_collision(body: Node2D) -> void:
	if body.is_in_group("Player"):
		World.emit_pulse(Player.target_point())
		Player.on_hit()
		
func environment_change() -> void:
	navigation.increase_tree_limit(100)

func _ready() -> void:
	navigation = RTTstarNavigationGD.new()
	nd = HolonomicND.new()
	
	add_child(navigation)
	add_child(nd)

	if World.show_navigation:
		_path_display = RTTstarDisplay.new()
		_path_display.show_connections = true
		_path_display.marker_radius = 8.0
		_path_display.marker_outline_width = 1.0
		World.add_child(_path_display)

	World.game_finished.connect(disable)

	var maze = World.get_maze()

	if maze:
		maze.maze_changed.connect(environment_change)

func _exit_tree() -> void:
	if _path_display:
		_path_display.queue_free()

func disable() -> void:
	set_process(false)
	set_physics_process(false)


func looking_dir_x() -> float:
	if abs(global_rotation) > PI/2:
		return -scale.x
	else:
		return scale.x

func look_to(direction: float) -> void:
	if sign(direction) != looking_dir_x():
		scale.x = -scale.x

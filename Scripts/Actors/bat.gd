extends CharacterBody2D


@export var FLY_SPEED: float = 1 * World.ppu

var navigation: RTTstarNavigationGD
var nd: HolonomicND
const DISTANCE_EPSILON: float = World.ppu * 0.5
var _path_display: RTTstarDisplay = null


## Follow a trajectory generated by the navigation system
func _physics_process(_delta: float) -> void:
	
	var target := _compute_direction()
	var direction := nd.compute_direction(global_position, target)

	velocity = direction * FLY_SPEED

	if velocity.x != 0 and sign(velocity.x) != looking_dir_x():
		scale.x = -scale.x

	move_and_slide() # Update physics


## Compute the direction to the player, using navigation if needed
func _compute_direction() -> Vector2:
	var player = Player.global_position

	# Direct path to player is clear, go directly
	if not World.ray_intersects_ground(global_position, player):
		return player
	else:
		###################### Global navigation #########################

		var path := navigation.generate_trajectory(global_position, player)
		if path.is_empty():
			World.log("No path found for actor at ", global_position, " to player at ", player)
			velocity = Vector2.ZERO
			return Vector2.ZERO

		# Compute where in the path we should go
		var target_idx := _go_to_trajectory(path)

		# Check that the path is reachable
		if World.ray_intersects_ground(global_position, path[target_idx]):
			navigation.restart(global_position)
			World.log("Actor cannot travel to path node ", path[target_idx], ", clearing tree")
			return Vector2.ZERO

		# We are already at the target, move to the next one
		if global_position.distance_to(path[target_idx]) < DISTANCE_EPSILON \
			and target_idx < path.size() - 1:
				target_idx += 1 # Move to the next target

		# Update path display
		if _path_display:
			_path_display.set_positions(path)
			_path_display.set_current_objective(target_idx)

		return path[target_idx]


## Returns the path index that the actor should head towards from a given trajectory
func _go_to_trajectory(new_path: PackedVector2Array) -> int:
	var min_dist = INF
	var best_segment = 0
	
	# Find closest point on path segments
	for i in range(new_path.size() - 1):
		var closest = Geometry2D.get_closest_point_to_segment(global_position, new_path[i], new_path[i + 1])
		var dist = global_position.distance_squared_to(closest)
		if dist < min_dist:
			min_dist = dist
			best_segment = i

	return best_segment + 1



func _ready() -> void:
	navigation = RTTstarNavigationGD.new()
	nd = HolonomicND.new()
	
	add_child(navigation)
	add_child(nd)

	_path_display = RTTstarDisplay.new()
	_path_display.show_connections = true
	_path_display.marker_radius = 8.0
	_path_display.marker_outline_width = 1.0
	World.add_child(_path_display)

	World.game_finished.connect(disable)

func _exit_tree() -> void:
	if _path_display:
		_path_display.queue_free()

func disable() -> void:
	set_process(false)
	set_physics_process(false)


func looking_dir_x() -> float:
	if abs(global_rotation) > PI/2:
		return -scale.x
	else:
		return scale.x

func look_to(direction: float) -> void:
	if sign(direction) != looking_dir_x():
		scale.x = -scale.x

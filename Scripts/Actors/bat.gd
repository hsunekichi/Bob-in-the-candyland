extends CharacterBody2D


@export var FLY_SPEED: float = 1 * World.ppu

var navigation: RTTstarNavigationGD
var nd: HolonomicND
const DISTANCE_EPSILON: float = World.ppu * 0.5
var _path_display: RTTstarDisplay = null
var MAX_PLAYER_DISTANCE: float = World.ppu * 40

# Hysteresis for path following (prevents rare target index flip-flop)
var _path_target_idx: int = 0

## Follow a trajectory generated by the navigation system
func _physics_process(_delta: float) -> void:
	if Player.global_position.distance_to(global_position) > MAX_PLAYER_DISTANCE:
		velocity = Vector2.ZERO
		return
	
	var target := _compute_direction()
	if target != Vector2.ZERO:
		target = nd.compute_direction(global_position, target)

	velocity = target * FLY_SPEED

	if velocity.x != 0 and sign(velocity.x) != looking_dir_x():
		scale.x = -scale.x

	move_and_slide() # Update physics


## Compute the direction to the player, using navigation if needed
func _compute_direction() -> Vector2:
	var player = Player.target_point()

	# Direct path to player is clear, go directly
	if not World.ray_intersects_ground(global_position, player):
		_path_target_idx = 0
		return player
	else:
		###################### Global navigation #########################

		var path := navigation.generate_trajectory(global_position, player)
		if path.is_empty():
			World.log("No path found for actor at ", global_position, " to player at ", player)
			_path_target_idx = 0
			velocity = Vector2.ZERO
			return Vector2.ZERO

		# Compute where in the path we should go
		var target_idx := _go_to_trajectory(path)

		# Check that the path is reachable
		if World.ray_intersects_ground(global_position, path[target_idx]):
			navigation.restart(global_position)
			_path_target_idx = 0
			World.log("Actor cannot travel to path node ", path[target_idx], ", clearing tree")
			return Vector2.ZERO

		# Update path display
		if _path_display:
			_path_display.set_positions(path)
			_path_display.set_current_objective(target_idx)

		return path[target_idx]


## Returns the path index that the actor should head towards from a given trajectory
func _go_to_trajectory(new_path: PackedVector2Array) -> int:
	if new_path.size() < 2:
		_path_target_idx = 0
		return 0

	# Clamp previous target index to this path
	if _path_target_idx >= new_path.size():
		_path_target_idx = new_path.size() - 1
	if _path_target_idx < 0:
		_path_target_idx = 0

	var min_dist = INF
	var best_segment = 0
	
	# Find closest point on path segments
	for i in range(new_path.size() - 1):
		var closest = Geometry2D.get_closest_point_to_segment(global_position, new_path[i], new_path[i + 1])
		var dist = global_position.distance_squared_to(closest)
		if dist <= min_dist: # Favor later segments in case of ties
			min_dist = dist
			best_segment = i
	
	var target = best_segment + 1

	# If we're close enough to the current objective, advance it.
	if _path_target_idx > 0 and global_position.distance_squared_to(new_path[_path_target_idx]) <= DISTANCE_EPSILON * DISTANCE_EPSILON:
		_path_target_idx = min(_path_target_idx + 1, new_path.size() - 1)

	# Never go backwards along the path (prevents rare flip-flop between adjacent points)
	target = maxi(target, _path_target_idx)

	# We have the closest segment. Now, if the next point is not obstructed, we directly go to it
	var skip_dist := (DISTANCE_EPSILON * 4.0)
	if (
		target + 1 < new_path.size()
		and global_position.distance_squared_to(new_path[target]) <= skip_dist * skip_dist
		and not World.ray_intersects_ground(global_position, new_path[target + 1])
	):
		target += 1

	_path_target_idx = target

	return target


func actor_collision(body: Node2D) -> void:
	if body.is_in_group("Player"):
		var point = Player.target_point()
		if Player.on_hit():
			World.emit_pulse(point)
		
func environment_change() -> void:
	navigation.increase_tree_limit(100)

func _ready() -> void:
	navigation = RTTstarNavigationGD.new()
	nd = HolonomicND.new()
	
	add_child(navigation)
	add_child(nd)

	if World.show_navigation:
		_path_display = RTTstarDisplay.new()
		_path_display.show_connections = true
		_path_display.marker_radius = 8.0
		_path_display.marker_outline_width = 1.0
		World.add_child(_path_display)

	World.game_finished.connect(disable)

	var maze = World.get_maze()

	if maze:
		maze.maze_changed.connect(environment_change)

func _exit_tree() -> void:
	if _path_display:
		_path_display.queue_free()

func disable() -> void:
	set_process(false)
	set_physics_process(false)


func looking_dir_x() -> float:
	if abs(global_rotation) > PI/2:
		return -scale.x
	else:
		return scale.x

func look_to(direction: float) -> void:
	if sign(direction) != looking_dir_x():
		scale.x = -scale.x
